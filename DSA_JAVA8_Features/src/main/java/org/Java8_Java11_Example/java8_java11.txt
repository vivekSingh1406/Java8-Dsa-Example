1. What are the main features introduced in Java 8?
=>
    Lambda Expressions – anonymous functions for concise behavior implementation
    Functional Interfaces – interfaces with a single abstract method (e.g., Runnable, Comparator)
    Stream API – process collections in a functional style
    Default & Static Methods in Interfaces – methods with implementations in interfaces
    Optional Class – avoids null checks and NullPointerException
    New Date and Time API – java.time package (thread-safe and immutable)


2. What is lazy evaluation in streams?
=>
    Intermediate operations like filter(), map(), sorted() are lazy, meaning they are not executed until a
    terminal operation like collect(), forEach(), or count() is called.

    Benefit:
        Efficient processing
        Avoids unnecessary computations

3. What are the main features introduced in Java 11?
=>
    Local-Variable Syntax for Lambda Parameters (var)
    HTTP Client API (Standardized) – Improved HTTP communication using HttpClient
    New String Methods – isBlank(), lines(), strip(), repeat()
    File Methods – readString(), writeString() in Files class
    Pattern Matching Preview (JEP 305) – Early pattern matching
    Removed deprecated APIs – e.g., Nashorn JS engine

4. What are the new String methods in Java 11?
=>
    isBlank()	Returns true if string is empty or whitespace
    lines()	Returns a stream of lines
    strip()	Removes leading/trailing whitespace
    repeat(n)	Repeats the string n times

5. What is the use of var in lambda parameters in Java 11?
=>
    Java 11 allows the use of var in lambda parameter declarations to support annotations.
    Example:
        (list.stream().map((@Nonnull var s) -> s.toUpperCase()));


6. How is Java 11 different from Java 8 in terms of LTS and support?
=>
    Both Java 8 and Java 11 are Long-Term Support (LTS) versions.
    Java 8 is older and lacks modern features (like modules, var, new APIs).
    Java 11 is more performant, cleaner, and better for microservices (especially with HTTP Client, improved GC, etc.)


7. Why we use method reference and constructor reference?
=>
    We use method references and constructor references in Java mainly to make our code shorter,
    cleaner, and easier to read when using functional programming (like streams, lambdas, etc.).

    Method Reference
    A method reference is a shorthand for a lambda expression that just calls an existing method.

    Why use it:-
        - Less code to write.
        - Improves readability when the lambda only calls a method.

    Example:-

        list.forEach(System.out::println);
        -  System.out → object
        -  println → method being called
        -  :: → method reference operator


    Constructor Reference
    A constructor reference is a shortcut for creating new objects in a lambda.

    When to use them:-
        - When your lambda just calls an existing method or constructor.
        - When you want cleaner and more expressive code.

8. Java Stream map() vs. flatMap()
=>
    map() :- The map() operation is used to transform each element of a stream into another
    object using a given function. It returns a new stream containing the transformed elements
    in the same order as the original stream.

    flatMap() :- The flatMap() operation is used when each element in the stream is transformed
    into multiple elements, often in the form of another collection or stream. The resulting
    elements are then flattened into a single stream.